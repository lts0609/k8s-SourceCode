# 调度框架与流程

由于生产环境中Kubernetes系统的复杂性越来越高，原生`default- scheduler`无法满足复杂的调度需求，为了避免代码过于庞大和复杂，Kubernetes通过扩展插件`Scheduler Extender`和多调度器`Multiple Schedulers`的方式来增强调度器的可扩展性。

参考官方文档[调度器配置](https://kubernetes.io/zh-cn/docs/reference/scheduling/config/)，我们可以创建一个配置文件，包含调度过程中所需要的插件列表以及调度器实例。

```yaml
// 扩展插件
apiVersion: kubescheduler.config.k8s.io/v1
kind: KubeSchedulerConfiguration
profiles:
  - plugins:
      score:
        disabled:
        - name: PodTopologySpread
        enabled:
        - name: MyCustomPluginA
          weight: 2
        - name: MyCustomPluginB
          weight: 1

// 多调度器
apiVersion: kubescheduler.config.k8s.io/v1
kind: KubeSchedulerConfiguration
profiles:
  - schedulerName: default-scheduler
  - schedulerName: no-scoring-scheduler
    plugins:
      preScore:
        disabled:
        - name: '*'
      score:
        disabled:
        - name: '*'
```

回顾调度器中的`schedulerOptions`结构体，回想在调度器创建过程中的第一件事就是生成并补全配置信息，也就是完善一个`Options/schedulerOptions`结构体，整体流程如下，只保留最重要的部分。

首先是程序入口`NewSchedulerCommand`处会创建一个`options.Options`对象，并在后续过程中一直被使用和更改。

```Go
// cmd路径下的调度器创建入口
func NewSchedulerCommand(registryOptions ...Option) *cobra.Command {
  ......
  // 新建对象
	opts := options.NewOptions()
  cmd := &cobra.Command{
    ......
    // 把opt传入runCommand
		RunE: func(cmd *cobra.Command, args []string) error {
			return runCommand(cmd, opts, registryOptions...)
		}
	}
}
```

实际创建逻辑`runCommand`中，`Options`对象被用于生成`CompletedConfig`配置信息和`Scheduler`实例。

```Go
func runCommand(cmd *cobra.Command, opts *options.Options, registryOptions ...Option) error {
  ......
	cc, sched, err := Setup(ctx, opts, registryOptions...)
	return Run(ctx, cc, sched)
}
```

在`Setup`以前，`Options`对象中的配置主要是开关类型，在这个流程中生成了

```Go
func Setup(ctx context.Context, opts *options.Options, outOfTreeRegistryOptions ...Option) (*schedulerserverconfig.CompletedConfig, *scheduler.Scheduler, error) {
  // 从这里开始给Options对象注入ComponentConfig字段
	if cfg, err := latest.Default(); err != nil {
		return nil, nil, err
	} else {
		opts.ComponentConfig = cfg
	}

	if errs := opts.Validate(); len(errs) > 0 {
		return nil, nil, utilerrors.NewAggregate(errs)
	}

	c, err := opts.Config(ctx)
	if err != nil {
		return nil, nil, err
	}

	// Get the completed config
	cc := c.Complete()

	outOfTreeRegistry := make(runtime.Registry)
	for _, option := range outOfTreeRegistryOptions {
		if err := option(outOfTreeRegistry); err != nil {
			return nil, nil, err
		}
	}

	recorderFactory := getRecorderFactory(&cc)
	completedProfiles := make([]kubeschedulerconfig.KubeSchedulerProfile, 0)
	// Create the scheduler.
	sched, err := scheduler.New(ctx,
		cc.Client,
		cc.InformerFactory,
		cc.DynInformerFactory,
		recorderFactory,
		scheduler.WithComponentConfigVersion(cc.ComponentConfig.TypeMeta.APIVersion),
		scheduler.WithKubeConfig(cc.KubeConfig),
		scheduler.WithProfiles(cc.ComponentConfig.Profiles...),
		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),
		scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),
		scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),
		scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),
		scheduler.WithPodMaxInUnschedulablePodsDuration(cc.PodMaxInUnschedulablePodsDuration),
		scheduler.WithExtenders(cc.ComponentConfig.Extenders...),
		scheduler.WithParallelism(cc.ComponentConfig.Parallelism),
		scheduler.WithBuildFrameworkCapturer(func(profile kubeschedulerconfig.KubeSchedulerProfile) {
			// Profiles are processed during Framework instantiation to set default plugins and configurations. Capturing them for logging
			completedProfiles = append(completedProfiles, profile)
		}),
	)
	if err != nil {
		return nil, nil, err
	}
	if err := options.LogOrWriteConfig(klog.FromContext(ctx), opts.WriteConfigTo, &cc.ComponentConfig, completedProfiles); err != nil {
		return nil, nil, err
	}

	return &cc, sched, nil
}
```
